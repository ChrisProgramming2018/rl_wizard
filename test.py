import unittest
import argparse
from game import createDeck, Game 

class TestProgram(unittest.TestCase):
    def test_case1(self):
        parser = argparse.ArgumentParser(description='Rainbow')
        parser.add_argument('--seed', type=int, default=0, help='Random seed')
        parser.add_argument('--state_size', type=int, default=58, help='Disable CUDA')
        parser.add_argument('--epochs', type=int, default=int(1e6), metavar='STEPS', help='Number of training steps (4x number of frames)')
        parser.add_argument('--history-length', type=int, default=1, metavar='T', help='Number of consecutive states processed')
        parser.add_argument('--hidden-size-1', type=int, default=128, metavar='SIZE', help='Network hidden size')
        parser.add_argument('--hidden-size-2', type=int, default=64, metavar='SIZE', help='Network hidden size')
        parser.add_argument('--noisy-std', type=float, default=0.1, metavar='sigma', help='Initial standard deviation of noisy linear layers')
        parser.add_argument('--buffer-size', type=int, default=int(1e6), metavar='CAPACITY', help='Experience replay memory capacity')
        parser.add_argument('--replay-frequency', type=int, default=10, metavar='k', help='Frequency of sampling from memory')
        parser.add_argument('--multi-step', type=int, default=7, metavar='n', help='Number of steps for multi-step return')
        parser.add_argument('--discount', type=float, default=0.999, metavar='gamma', help='Discount factor')
        parser.add_argument('--target-update', type=int, default=int(4), metavar='tau', help='Number of steps after which to update target network')
        parser.add_argument('--reward-clip', type=int, default=0, metavar='VALUE', help='Reward clipping (0 to disable)')
        parser.add_argument('--lr', type=float, default=5e-4, metavar='mue', help='Learning rate')
        parser.add_argument('--tau', type=float, default=1e-3, metavar='eps', help='Adam epsilon')
        parser.add_argument('--batch_size', type=int, default=64, metavar='SIZE', help='Batch size')
        parser.add_argument('--learn-start', type=int, default=int(5000), metavar='STEPS', help='Number of steps before starting training')
        parser.add_argument('--evaluate', action='store_true', help='Evaluate only')
        parser.add_argument('--evaluation-interval', type=int, default=1000, metavar='STEPS', help='Number of training steps between evaluations')
        parser.add_argument('--evaluation-episodes', type=int, default=10, metavar='N', help='Number of evaluation episodes to average over')
        parser.add_argument('--evaluation-size', type=int, default=50000, metavar='N', help='Number of transitions to use for validating Q')
        parser.add_argument('--update-every', default=10000)
        parser.add_argument('--eps_decay', type=float, default=0.99)
        parser.add_argument('--n_episodes', default=2000)
        parser.add_argument('--locexp', type=str , default = 'sep')
        parser.add_argument('--device', default='cuda')
        arg = parser.parse_args() 
        # print(arg)
        deck = createDeck()
        game = Game(arg, deck)
        game.reset_round(1)
        # check player 1 starts game
        self.assertTrue(game.player1.token == True)
        self.assertTrue(game.player2.token == False)
        print(game.player2.token)
        print(game.player1.current_cards)
        print(game.player2.current_cards)
        print(game.current_trumph)
        game.set_estimate(0, 0)
        game.play_cards(0, 0)
        game.evalute_game()

        # check score
        self.assertTrue(game.player1.score == 20)
        self.assertTrue(game.player2.score == 0)
        print(game.player1.score)
        print(game.player2.score)

    def test_case2(self):
        parser = argparse.ArgumentParser(description='Rainbow')
        parser.add_argument('--seed', type=int, default=0, help='Random seed')
        parser.add_argument('--state_size', type=int, default=58, help='Disable CUDA')
        parser.add_argument('--epochs', type=int, default=int(1e6), metavar='STEPS', help='Number of training steps (4x number of frames)')
        parser.add_argument('--history-length', type=int, default=1, metavar='T', help='Number of consecutive states processed')
        parser.add_argument('--hidden-size-1', type=int, default=128, metavar='SIZE', help='Network hidden size')
        parser.add_argument('--hidden-size-2', type=int, default=64, metavar='SIZE', help='Network hidden size')
        parser.add_argument('--noisy-std', type=float, default=0.1, metavar='sigma', help='Initial standard deviation of noisy linear layers')
        parser.add_argument('--buffer-size', type=int, default=int(1e6), metavar='CAPACITY', help='Experience replay memory capacity')
        parser.add_argument('--replay-frequency', type=int, default=10, metavar='k', help='Frequency of sampling from memory')
        parser.add_argument('--multi-step', type=int, default=7, metavar='n', help='Number of steps for multi-step return')
        parser.add_argument('--discount', type=float, default=0.999, metavar='gamma', help='Discount factor')
        parser.add_argument('--target-update', type=int, default=int(4), metavar='tau', help='Number of steps after which to update target network')
        parser.add_argument('--reward-clip', type=int, default=0, metavar='VALUE', help='Reward clipping (0 to disable)')
        parser.add_argument('--lr', type=float, default=5e-4, metavar='mue', help='Learning rate')
        parser.add_argument('--tau', type=float, default=1e-3, metavar='eps', help='Adam epsilon')
        parser.add_argument('--batch_size', type=int, default=64, metavar='SIZE', help='Batch size')
        parser.add_argument('--learn-start', type=int, default=int(5000), metavar='STEPS', help='Number of steps before starting training')
        parser.add_argument('--evaluate', action='store_true', help='Evaluate only')
        parser.add_argument('--evaluation-interval', type=int, default=1000, metavar='STEPS', help='Number of training steps between evaluations')
        parser.add_argument('--evaluation-episodes', type=int, default=10, metavar='N', help='Number of evaluation episodes to average over')
        parser.add_argument('--evaluation-size', type=int, default=50000, metavar='N', help='Number of transitions to use for validating Q')
        parser.add_argument('--update-every', default=10000)
        parser.add_argument('--eps_decay', type=float, default=0.99)
        parser.add_argument('--n_episodes', default=2000)
        parser.add_argument('--locexp', type=str , default = 'sep')
        parser.add_argument('--device', default='cuda')
        arg = parser.parse_args() 
        # print(arg)
        deck = createDeck()
        game = Game(arg, deck)
        game.reset_round(1)
        # check player 1 starts game
        self.assertTrue(game.player1.token == True)
        self.assertTrue(game.player2.token == False)
        print(game.player2.token)
        game.player1.current_cards = ['B3']
        game.player2.current_cards = ['R3']
        print(game.player1.current_cards)
        print(game.player2.current_cards)
        print(game.current_trumph)
        game.set_estimate(0, 0)
        game.play_cards(0, 0)
        game.evalute_game()

        # check score
        self.assertTrue(game.player1.score == 0)
        self.assertTrue(game.player2.score == 20)
        print(game.player1.score)
        print(game.player2.score)

    def test_case2(self):
        parser = argparse.ArgumentParser(description='Rainbow')
        parser.add_argument('--seed', type=int, default=0, help='Random seed')
        parser.add_argument('--state_size', type=int, default=58, help='Disable CUDA')
        parser.add_argument('--epochs', type=int, default=int(1e6), metavar='STEPS', help='Number of training steps (4x number of frames)')
        parser.add_argument('--history-length', type=int, default=1, metavar='T', help='Number of consecutive states processed')
        parser.add_argument('--hidden-size-1', type=int, default=128, metavar='SIZE', help='Network hidden size')
        parser.add_argument('--hidden-size-2', type=int, default=64, metavar='SIZE', help='Network hidden size')
        parser.add_argument('--noisy-std', type=float, default=0.1, metavar='sigma', help='Initial standard deviation of noisy linear layers')
        parser.add_argument('--buffer-size', type=int, default=int(1e6), metavar='CAPACITY', help='Experience replay memory capacity')
        parser.add_argument('--replay-frequency', type=int, default=10, metavar='k', help='Frequency of sampling from memory')
        parser.add_argument('--multi-step', type=int, default=7, metavar='n', help='Number of steps for multi-step return')
        parser.add_argument('--discount', type=float, default=0.999, metavar='gamma', help='Discount factor')
        parser.add_argument('--target-update', type=int, default=int(4), metavar='tau', help='Number of steps after which to update target network')
        parser.add_argument('--reward-clip', type=int, default=0, metavar='VALUE', help='Reward clipping (0 to disable)')
        parser.add_argument('--lr', type=float, default=5e-4, metavar='mue', help='Learning rate')
        parser.add_argument('--tau', type=float, default=1e-3, metavar='eps', help='Adam epsilon')
        parser.add_argument('--batch_size', type=int, default=64, metavar='SIZE', help='Batch size')
        parser.add_argument('--learn-start', type=int, default=int(5000), metavar='STEPS', help='Number of steps before starting training')
        parser.add_argument('--evaluate', action='store_true', help='Evaluate only')
        parser.add_argument('--evaluation-interval', type=int, default=1000, metavar='STEPS', help='Number of training steps between evaluations')
        parser.add_argument('--evaluation-episodes', type=int, default=10, metavar='N', help='Number of evaluation episodes to average over')
        parser.add_argument('--evaluation-size', type=int, default=50000, metavar='N', help='Number of transitions to use for validating Q')
        parser.add_argument('--update-every', default=10000)
        parser.add_argument('--eps_decay', type=float, default=0.99)
        parser.add_argument('--n_episodes', default=2000)
        parser.add_argument('--locexp', type=str , default = 'sep')
        parser.add_argument('--device', default='cuda')
        arg = parser.parse_args() 
        # print(arg)
        deck = createDeck()
        game = Game(arg, deck)
        game.reset_round(1)
        # check player 1 starts game
        self.assertTrue(game.player1.token == True)
        self.assertTrue(game.player2.token == False)
        print(game.player2.token)
        game.player1.current_cards = ['B6']
        game.player2.current_cards = ['B4']
        print(game.player1.current_cards)
        print(game.player2.current_cards)
        print(game.current_trumph)
        game.set_estimate(0, 0)
        game.play_cards(0, 0)
        game.evalute_game()

        # check score
        self.assertTrue(game.player1.score == 0)
        self.assertTrue(game.player2.score == 20)
        print(game.player1.score)
        print(game.player2.score)




if __name__ == "__main__":
    unittest.main()
